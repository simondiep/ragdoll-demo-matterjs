<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.12.0/matter.min.js"></script>
<script>
  let engine;
  let canvas;
  let context;
  let chest; // Focal point
  const renderWidth = 1200;
  const renderHeight = 600;

  // To bound the world coordinates
  const worldXMin = -10000;
  const worldXMax = 10000;
  const worldYMin = -1000;
  const worldYMax = 10000;

  window.onload = function () {
    canvas = document.createElement('canvas');
    context = canvas.getContext('2d');
    canvas.width = renderWidth;
    canvas.height = renderHeight;
    document.body.appendChild(canvas);

    // module aliases
    const { Bodies, Engine, Render, World } = Matter;
    // Matter.Resolver._restingThresh = 100;
    engine = Engine.create({
      gravity: { x: 0, y: 1 }
    });

    World.add(engine.world, [
      // ground
      Bodies.rectangle(worldXMin / 2, renderHeight + 250, worldXMax * 4, 250, { isStatic: true, render: { fillStyle: 'green' } }),
    ]);

    // create two boxes
    const boxA = Bodies.rectangle(400, 200, 80, 80);
    const boxB = Bodies.rectangle(450, 50, 80, 80);
    const boxToBoxConstraint = Matter.Constraint.create({
      bodyA: boxA,
      bodyB: boxB,
    });
    const boxes = Matter.Composite.create({
      bodies: [
        boxA, boxB,
      ],
      constraints: [
        boxToBoxConstraint,
      ]
    });

    // create ragdoll
    const ragdoll = createRagdoll(200, 400);

    // add all of the bodies to the world
    World.add(engine.world, [ragdoll, boxes]);

    Engine.run(engine);

    setInterval(render, 1000 / 60);
  }

  /**************************
   * Render functions start *
   **************************/

  function adjustCameraToPlayer() {
    function clamp(value, min, max) {
      if (value < min) return min;
      else if (value > max) return max;
      return value;
    }

    context.setTransform(1, 0, 0, 1, 0, 0);//reset the transform matrix as it is cumulative

    const playerCoordinates = {
      x: chest.vertices[0].x,
      y: chest.vertices[0].y,
    };
    const perceivedHeight = renderHeight - playerCoordinates.y;

    // Darken background the higher the player is
    if (perceivedHeight < 1000) {
      context.fillStyle = '#ccffff';
    } else if (perceivedHeight < 2000) {
      context.fillStyle = '#66ffff';
    } else if (perceivedHeight < 3000) {
      context.fillStyle = '#00ffff';
    } else if (perceivedHeight < 4000) {
      context.fillStyle = '#33cccc';
    } else if (perceivedHeight < 5000) {
      context.fillStyle = '#006699';
    } else if (perceivedHeight < 6000) {
      context.fillStyle = '#003366';
    } else {
      context.fillStyle = 'black';
    }
    context.fillRect(0, 0, renderWidth, renderHeight);

    //Clamp the camera position to the world bounds while centering the camera around the player  
    var camX = clamp(-playerCoordinates.x + renderWidth / 2, worldXMin, worldXMax - renderWidth);
    var camY = clamp(-playerCoordinates.y + renderHeight * 3 / 5, worldYMin, worldYMax - renderHeight);

    context.translate(camX, camY);

    document.getElementById('xPosition').innerHTML = playerCoordinates.x.toFixed(0);
    document.getElementById('yPosition').innerHTML = perceivedHeight.toFixed(0);
  }

  function render() {
    var bodies = Matter.Composite.allBodies(engine.world);

    adjustCameraToPlayer();

    for (var i = 0; i < bodies.length; i += 1) {
      if (bodies[i].parts.length > 1) {
        for (let part of bodies[i].parts) {
          renderBodyPart(part);
        }
      } else {
        renderBodyPart(bodies[i]);
      }
    }
  }
  // Custom renderer
  function renderBodyPart(bodyPart) {
    if (bodyPart.label === "Body") {
      return;
    }
    var vertices = bodyPart.vertices;
    context.beginPath();
    context.moveTo(vertices[0].x, vertices[0].y);

    for (var j = 1; j < vertices.length; j += 1) {
      context.lineTo(vertices[j].x, vertices[j].y);
    }

    context.lineTo(vertices[0].x, vertices[0].y);
    context.closePath();
    context.fillStyle = bodyPart.render.fillStyle;
    context.fill();
  }

  /**************************
   * Render functions end *
   **************************/

  // Create body parts and assemble them into a ragdoll
  function createRagdoll(x, y) {
    // aliases
    const { Bodies, Body, Composite, Constraint } = Matter;

    const defaultCollisionGroup = -1;

    /*********************
     * Define Body Parts *
     *********************/
    const headOptions = {
      friction: 1,
      frictionAir: .05,
      render: {
        fillStyle: '#FFBC42',
      },
    };
    const chestOptions = {
      friction: 1,
      frictionAir: .05,
      collisionFilter: {
        group: defaultCollisionGroup - 1
      },
      chamfer: {
        radius: 20,
      },
      render: {
        fillStyle: '#E0A423',
      },
    };
    const armOptions = {
      friction: 1,
      frictionAir: .03,
      collisionFilter: {
        group: defaultCollisionGroup
      },
      chamfer: {
        radius: 10,
      },
      render: {
        fillStyle: '#FFBC42',
      },
    };
    const legOptions = {
      friction: 1,
      frictionAir: .03,
      collisionFilter: {
        group: defaultCollisionGroup - 1
      },
      chamfer: {
        radius: 10,
      },
      render: {
        fillStyle: '#FFBC42',
      },
    };

    const lowerLegOptions = {
      friction: 1,
      frictionAir: .03,
      collisionFilter: {
        group: defaultCollisionGroup - 1
      },
      chamfer: {
        radius: 2,
      },
      render: {
        fillStyle: '#E59B12',
      },
    };

    const head = Bodies.circle(x, y - 70, 30, headOptions);
    chest = Bodies.rectangle(x, y, 60, 80, chestOptions);
    const rightUpperArm = Bodies.rectangle(x + 40, y - 20, 20, 40, Object.assign({}, armOptions));
    const rightLowerArm = Bodies.rectangle(x + 40, y + 20, 20, 60, Object.assign({}, armOptions));
    const leftUpperArm = Bodies.rectangle(x - 40, y - 20, 20, 40, Object.assign({}, armOptions));
    const leftLowerArm = Bodies.rectangle(x - 40, y + 20, 20, 60, Object.assign({}, armOptions));
    const leftUpperLeg = Bodies.rectangle(x - 20, y + 60, 20, 40, Object.assign({}, legOptions));
    const rightUpperLeg = Bodies.rectangle(x + 20, y + 60, 20, 40, Object.assign({}, legOptions));
    const leftLowerLeg = Bodies.rectangle(x - 20, y + 100, 20, 60, Object.assign({}, lowerLegOptions));
    const rightLowerLeg = Bodies.rectangle(x + 20, y + 100, 20, 60, Object.assign({}, lowerLegOptions));

    const legTorso = Body.create({
      parts: [chest, leftUpperLeg, rightUpperLeg],
      collisionFilter: {
        group: defaultCollisionGroup - 1
      },
    });

    /*****************************
     * Define Constraints/Joints *
     *****************************/
    const chestToRightUpperArm = Constraint.create({
      bodyA: legTorso,
      pointA: {
        x: 25,
        y: -40
      },
      pointB: {
        x: -5,
        y: -10
      },
      bodyB: rightUpperArm,
      stiffness: .2,
      render: {
        visible: false
      }
    });
    const chestToLeftUpperArm = Constraint.create({
      bodyA: legTorso,
      pointA: {
        x: -25,
        y: -40
      },
      pointB: {
        x: 5,
        y: -10
      },
      bodyB: leftUpperArm,
      stiffness: .2,
      render: {
        visible: false
      }
    });

    const upperToLowerRightArm = Constraint.create({
      bodyA: rightUpperArm,
      bodyB: rightLowerArm,
      pointA: {
        x: 0,
        y: 15
      },
      pointB: {
        x: 0,
        y: -20
      },
      stiffness: .2,
      render: {
        visible: false
      }
    });

    const upperToLowerLeftArm = Constraint.create({
      bodyA: leftUpperArm,
      bodyB: leftLowerArm,
      pointA: {
        x: 0,
        y: 15
      },
      pointB: {
        x: 0,
        y: -20
      },
      stiffness: .2,
      render: {
        visible: false
      }
    });

    const upperToLowerLeftLeg = Constraint.create({
      bodyA: legTorso,
      bodyB: leftLowerLeg,
      pointA: {
        x: -20,
        y: 60
      },
      pointB: {
        x: 0,
        y: -25
      },
      stiffness: .2,
      render: {
        visible: false
      }
    });

    const upperToLowerRightLeg = Constraint.create({
      bodyA: legTorso,
      bodyB: rightLowerLeg,
      pointA: {
        x: 20,
        y: 60
      },
      pointB: {
        x: 0,
        y: -25
      },
      stiffness: .2,
      render: {
        visible: false
      }
    });

    const headContraint = Constraint.create({
      bodyA: head,
      pointA: {
        x: 0,
        y: 20
      },
      pointB: {
        x: 0,
        y: -50
      },
      bodyB: legTorso,
      stiffness: .3,
      render: {
        visible: false
      }
    });

    window.addEventListener('keydown',
      (event) => {
        const FORCE_VALUE = 0.05;
        switch (event.keyCode) {
          case 81: //q
            Matter.Body.applyForce(leftLowerArm, leftLowerArm.position, { x: -FORCE_VALUE, y: -FORCE_VALUE });
            break;
          case 87: //w
            Matter.Body.applyForce(leftLowerLeg, leftLowerLeg.position, { x: -FORCE_VALUE, y: FORCE_VALUE });
            break;
          case 79: //o
            Matter.Body.applyForce(rightLowerArm, rightLowerArm.position, { x: FORCE_VALUE, y: -FORCE_VALUE });
            break;
          case 80: //p
            Matter.Body.applyForce(rightLowerLeg, rightLowerLeg.position, { x: FORCE_VALUE, y: FORCE_VALUE });
            break;
        }
      }
    );

    const person = Composite.create({
      bodies: [legTorso, head, leftLowerArm, leftUpperArm, rightLowerArm, rightUpperArm, leftLowerLeg, rightLowerLeg],
      constraints: [upperToLowerLeftArm, upperToLowerRightArm, chestToLeftUpperArm, chestToRightUpperArm, headContraint, upperToLowerLeftLeg, upperToLowerRightLeg]
    });
    return person;
  }
</script>
<div>Make the person fly by pressing qwop</div>
<div>
  <label>Distance</label>
  <label id="xPosition"></label>
</div>
<div>
  <label>Height</label>
  <label id="yPosition"></label>
</div>